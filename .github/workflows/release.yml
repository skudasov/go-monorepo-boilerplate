on:
  push:
    tags:
      - '*/v*.*.*'  # Trigger only on tags with the format $package/vX.X.X

permissions:
  contents: write
  packages: write

jobs:
  release_binaries:
    strategy:
      matrix:
        platform: [ "linux", "darwin" ]
        goarch: [ "amd64", "arm64" ]
    name: release linux/amd64
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Extract Package Name from Tag
        id: extract_package_name
        run: |
          TAG_REF="${GITHUB_REF#refs/tags/}"
          PACKAGE_NAME=$(echo "$TAG_REF" | cut -d'/' -f1)
          VERSION=$(echo "$TAG_REF" | cut -d'/' -f2)
          echo "Tag Reference: $TAG_REF"
          echo "Package Name: $PACKAGE_NAME"
          echo "Version: $VERSION"
          
          echo "PACKAGE_NAME=$PACKAGE_NAME" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
      - name: Show Package Name and Version
        run: |
          echo "Package Name: ${{ env.PACKAGE_NAME }}"
          echo "Version: ${{ env.VERSION }}"
      - name: Find Last Tag for Package and Generate Release Notes
        id: generate_release_notes
        run: |
          # Find the latest tag for the same package that is not the current tag
          LAST_TAG=$(git tag --list "${{ env.PACKAGE_NAME }}/v*" --sort=-v:refname | grep -v "${{ env.VERSION }}" | head -n 1)

          # If no previous tag is found, use the initial commit as the reference
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi

          # Get the commits between the last tag and the current tag
          COMMITS=$(git log "$LAST_TAG..${GITHUB_SHA}" --pretty=format:"- %s (%h)")

          # Output the release notes
          echo "Release notes:"
          echo "$COMMITS"

          # Set the release notes as an environment variable for use in the next step
          echo "RELEASE_NOTES=$COMMITS" >> $GITHUB_ENV
      - name: Read Additional Release Notes from File
        working-directory: ${{ env.PACKAGE_NAME }}
        id: read_additional_notes
        run: |
          # Check if the .release_notes directory exists and the file for the current version is present
          if [ -f ".release_notes/${{ env.VERSION }}.md" ]; then
            # Read the content of the file
            ADDITIONAL_NOTES=$(cat ".release_notes/${{ env.VERSION }}.md")

            # Surround the additional notes with newlines safely using heredoc
            echo "FULL_RELEASE_NOTES<<EOF" >> $GITHUB_ENV
            echo "${{ env.RELEASE_NOTES }}" >> $GITHUB_ENV
            echo "" >> $GITHUB_ENV
            echo "$ADDITIONAL_NOTES" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          else
            # Print error message and fail the pipeline if the file is not found
            echo "Error: Release notes file '.release_notes/${{ env.VERSION }}.md' not found."
            exit 1
          fi
      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          sudo apt-get install -y gh
          gh release create "${{ env.VERSION }}" --title "${{ env.PACKAGE_NAME }} ${{ env.VERSION }}" --notes "Release for ${{ env.PACKAGE_NAME }} version ${{ env.VERSION }}\n\n${{ env.FULL_RELEASE_NOTES }}" || true
      - uses: wangyoucao577/go-release-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          goos: ${{ matrix.platform }}
          goarch: ${{ matrix.goarch }}
          release_name: ${{ env.PACKAGE_NAME }}
          release_tag: ${{ env.VERSION }}
          project_path: ${{ env.PACKAGE_NAME }}
          asset_name: ${{ env.PACKAGE_NAME }}-${{ env.VERSION }}-${{ matrix.platform }}-${{ matrix.goarch }}
